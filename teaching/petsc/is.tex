% -*- latex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This TeX file is part of the tutorial
%%%% `Introduction to the PETSc library'
%%%% Victor Eijkhout, eijkhout@tacc.utexas.edu
%%%% copyright Victor Eijkhout 2012-6
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sectionframe{IS and VecScatter: irregular grids}

\frame[containsverbatim]{\frametitle{Irregular data movement}

  Example: collect distributed boundary onto a single processor
  (this happens in the matrix-vector product)

  \includegraphics[scale=.07]{vecscatter}

  Problem: figuring out communication is hard, actual communication is
  cheap
}

\frame[containsverbatim]{\frametitle{VecScatter}
Preprocessing: determine mapping between input vector and output:
\begin{verbatim}
VecScatterCreate(Vec,IS,Vec,IS,VecScatter*) 
// also Destroy
\end{verbatim}
Application to specific vectors:
\begin{verbatim}
VecScatterBegin(VecScatter,
  Vec,Vec, InsertMode mode, ScatterMode direction)
VecScatterEnd  (VecScatter,
  Vec,Vec, InsertMode mode, ScatterMode direction)
\end{verbatim}
}

\frame[containsverbatim]{\frametitle{IS: index set}
Index Set is a set of indices
\begin{verbatim}
ISCreateGeneral(comm,n,indices,PETSC_COPY_VALUES,&is);
    /* indices can now be freed */
ISCreateStride (comm,n,first,step,&is);
ISCreateBlock  (comm,bs,n,indices,&is);

ISDestroy(is);
\end{verbatim}
Use \n{MPI_COMM_SELF} most of the time.

Various manipulations: \n{ISSum}, \n{ISDifference}, \n{ISInvertPermutations}
et cetera.\\
Also \n{ISGetIndices} / \n{ISRestoreIndices} / \n{ISGetSize}
}

\frame[containsverbatim]{\frametitle{Example: simulate allgather}
\small
\begin{verbatim}
/* create the distributed vector with one element per processor */
ierr = VecCreate(MPI_COMM_WORLD,&global); 
ierr = VecSetType(global,VECMPI); 
ierr = VecSetSizes(global,1,PETSC_DECIDE); 

/* create the local copy */
ierr = VecCreate(MPI_COMM_SELF,&local); 
ierr = VecSetType(local,VECSEQ); 
ierr = VecSetSizes(local,ntids,ntids); 
\end{verbatim}
}

\frame[containsverbatim]{
\small
\begin{verbatim}
IS indices;
ierr = ISCreateStride(MPI_COMM_SELF,ntids,0,1, &indices); 
/* create a scatter from the source indices to target */
ierr = VecScatterCreate
  (global,indices,local,indices,&scatter); 
/* index set is no longer needed */
ierr = ISDestroy(&indices); 
\end{verbatim}
}

\frame[containsverbatim]{\frametitle{Example: even and odd indices}
\small
\begin{verbatim}
if (mytid==0) {
  ierr = ISCreateStride
    (MPI_COMM_SELF,(N+1)/2,0,2, &gindices);  // even
} else {
  ierr = ISCreateStride
    (MPI_COMM_SELF,N/2,1,2, &gindices);  // odd
}
ierr = ISGetSize(gindices,&localsize); 
/* create a vector with the requisite local size */
ierr = VecCreate(MPI_COMM_WORLD,&in); 
ierr = VecSetType(in,VECMPI); 
ierr = VecSetSizes(in,localsize,N); 
\end{verbatim}
}

\frame[containsverbatim]{
Create local target vectors:
\small
\begin{verbatim}
/* create IS objects for the target locations */
ierr = ISCreateStride
  (MPI_COMM_SELF,localsize,0,1,&lindices); 
/* output vector is local */
ierr = VecCreate(MPI_COMM_SELF,&out); 
ierr = VecSetType(out,VECSEQ); 
ierr = VecSetSizes(out,localsize,localsize); 
\end{verbatim}
}

\frame[containsverbatim]{
Create and apply scatter:
\small
\begin{verbatim}
  /* create a scatter from the source indices to target */
  ierr = VecScatterCreate(in,gindices,out,lindices,&scatter); 
  /* index sets are no longer needed */
  ierr = ISDestroy(&gindices); 
  ierr = ISDestroy(&gindices); 

  ierr = VecScatterBegin
(scatter,in,out,INSERT_VALUES,SCATTER_FORWARD); 
  ierr = VecScatterEnd
(scatter,in,out,INSERT_VALUES,SCATTER_FORWARD); 
  VecView(out,0);
\end{verbatim}
}

\frame[containsverbatim]{
\tiny
\begin{verbatim}
Vector Object: 1 MPI processes
  type: seq
0
2
4
6
8
10
12
14
16
18
20
Vector Object: 1 MPI processes
  type: seq
1
3
5
7
9
11
13
15
17
19
21
\end{verbatim}
}

\frame[containsverbatim]{\frametitle{Same, but distributed output
    vector}
\begin{verbatim}
/* create IS objects for the target locations */
ierr = VecGetOwnershipRange(in,&myfirst,PETSC_NULL); 
ierr = ISCreateStride
  (MPI_COMM_SELF,localsize,myfirst,1,&lindices); 
/* output vectors will have the same size & layout as input */
ierr = VecDuplicate(in,&out); 
\end{verbatim}
}
