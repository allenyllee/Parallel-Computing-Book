\Level 0 {Basic concepts}

\Level 1 {Initialization / finalization}

Every program that uses MPI needs to initialize and finalize exactly
once. In~C, the calls are
\begin{verbatim}
ierr = MPI_Init(&argc,&argv);
// your code
ierr = MPI_Finalize();
\end{verbatim}
where \n{argc} and \n{argv} are the arguments of the main program.
%
The corresponding Fortran calls are
\begin{verbatim}
call MPI_Init(ierr)
// your code
call MPI_Finalize()
\end{verbatim}

We make a few observations.
\begin{itemize}
\item MPI routines return an error code. In~C, this is a function
  result; in Fortran it is the final parameter in the calling
  sequence.
\item For most routines, this parameter is the only difference between
  the C and Fortran calling sequence, but some routines differ in some
  respect related to the languages. In this case, C~has a mechanism
  for dealing with commandline arguments that Fortran lacks.
\item This error parameter is zero if the routine completes
  succesfully, and nonzero otherwise. You can write code to deal with
  the case of failure, but by default your program will simply abort
  on any MPI error. See section~\ref{mpi:error} for more details.
\end{itemize}

\Level 0 {Errors and debugging}

Errors in normal programs can be tricky to deal with; errors in
parallel programs can be even harder. This is because in addition to
everything that can go wrong with a single executable (floating point errors,
memory violation) you now get errors that come from faulty interaction
between multiple executables.

A few examples of what can go wrong:
\begin{itemize}
\item MPI errors: an MPI routine can abort for various reasons, such
  as receiving much more data than its buffer can accomodate. Such
  errors, as well as the more common type mentioned above, typically
  cause your whole execution to abort. That is, if one incarnation of
  your executable aborts, the MPI runtime will kill all others.
\item Deadlocks and other hanging executions: there are various
  scenarios where your processes individually do not abort, but are all
  waiting for each other. This can happen if two processes are both
  waiting for a message from each other, and this can be helped by
  using non-blocking calls. In another scenario, through an error in
  program logic, one process will be waiting for more messages
  (including non-blocking ones) than are sent to it.
\end{itemize}

\Level 1 {Error handling}
\label{mpi:error}

The MPI library has a general mechanism for dealing with errors that
it detects. The default behaviour, where the full run is aborted, is
equivalent to your code having the following statement\footnote{The
  routine \n{MPI\_Errhandler\_set} is deprecated.}  :
\begin{verbatim}
MPI_Comm_set errhandler_set(MPI_COMM_WORLD,MPI_ERRORS_ARE_FATAL);
\end{verbatim}
Another simple possibility is to specify
\begin{verbatim}
MPI_Comm_set errhandler_set(MPI_COMM_WORLD,MPI_ERRORS_RETURN);
\end{verbatim}
which gives you the opportunity to write code that handles the error
return value.

\Level 1 {Debugging}

\Level 0 {Literature}

Online resources:
\begin{itemize}
\item MPI 1 Complete reference:\\ \url{http://www.netlib.org/utk/papers/mpi-book/mpi-book.html}
\item Official MPI documents:\\ \url{http://www.mpi-forum.org/docs/}
\item List of all MPI routines:\\ \url{http://www.mcs.anl.gov/research/projects/mpi/www/www3/}
\end{itemize}

Tutorial books on MPI:
\begin{itemize}
\item Using MPI~\cite{Gropp:UsingMPI1} by some of the original authors.
\end{itemize}
