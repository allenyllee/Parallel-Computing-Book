% -*- latex -*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This text file is part of the source of 
%%%% `Parallel Programming in MPI and OpenMP'
%%%% by Victor Eijkhout, copyright 2012-2020
%%%%
%%%% petsc-tools.tex : guess.
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\Level 0 {Error checking and debugging}

\Level 1 {Error codes}

PETSc performs a good amount of runtime error checking. Some of this
is for internal consistency, but it can also detect certain
mathematical errors. To facilitate error reporting, the following
scheme is used.
\begin{enumerate}
\item Every PETSc routine is a function returning a parameter of type
  \indexpetscdef{PetscErrorCode}.
\item Calling the macro \indexpetscdef{CHKERRQ} on the error code will
  cause an error to be printed and the current routine to be
  terminated. Recursively this gives a traceback of where the error
  occurred.
\item You can effect your own error return by using \indexpetscdef{SETERRQ}.
\end{enumerate}
\begin{lstlisting}
PetscErrorCode ierr;
ierr = AnyPetscRoutine( arguments ); CHKERRQ(ierr);
\end{lstlisting}
\begin{fortrannote}
  In the main program, use \indexpetscdef{CHKERRA} and
  \indexpetscdef{SETERRA}. Also beware that these error `commands' are
  macros, and after expansion may interfere with
  \indextermbus{Fortran}{line length}.
\end{fortrannote}

\Level 1 {Memory corruption}

PETSc has its own memory management (section~\ref{sec:petscmalloc})
and this facilitates finding memory corruption errors.
The macro \indexpetscdef{CHKMEMQ} (\indexpetscdef{CHKMEMA} in void functions)
checks all memory that was allocated by PETSc,
either internally or throug the allocation routines,
for corruption. Sprinkling this macro through your code
can detect memory problems before they lead to a \indexterm{segfault}.

This testing is only done if the commandline argument
\indextermtt{-malloc_debug} (\indextermtt{-malloc_test} in debug mode)
is supplied, so it carries no overhead for production runs.

\Level 0 {Printing}

Printing screen output in parallel is tricky. If two processes execute
a print statement at more or less the same time there is no guarantee
as to in what order they may appear on screen. (Even attempts to have
them print one after the other may not result in the right ordering.)
Furthermore, lines from multi-line print actions on two processes may
wind up on the screen interleaved.

PETSc has two routines that fix this problem. First of all, often the
information printed is the same on all processes, so it is enough if
only one process, for instance process~0, prints it. This is done with
\indexpetscref{PetscPrintf}.


If all processes need to print, you can use
\indexpetscref{PetscSynchronizedPrintf} that forces the
output to appear in process order.

To make sure that output is properly flushed from all system buffers
use \indexpetscref{PetscSynchronizedFlush}
where for ordinary screen output you would use \n{stdout} for the file.

\begin{pythonnote}
  Since the print routines use the python \n{print} call, they
  automatically include the trailing newline. You don't have to
  specify it as in the C~calls.
\end{pythonnote}

\Level 0 {Commandline options}
\label{sec:petsc-options}

PETSc has as large number of commandline options, most of which we
will discuss later. For now we only mention \n{-log_summary} which
will print out profile of the time taken in various routines.
For these options to be parsed, it is necessary to pass \n{argc,argv}
to the \indexpetscshow{PetscInitialize} call.

\begin{pythonnote}
  In Python, do not specify the initial hyphen of an option name.
\begin{verbatim}
hasn = PETSc.Options().hasName("n")
\end{verbatim}
\end{pythonnote}

\Level 0 {Timing and profiling}

PETSc has a number of timing routines that make it unnecessary to
use system routines such as \indextermtt{getrusage}
or MPI routines such as \indexmpishow{MPI_Wtime}.
The main (wall clock) timer is \indexpetscref{PetscTime}.
Note the return type of \indexpetscdef{PetscLogDouble} which
can have a different precision from \indexpetscshow{PetscReal}.

The routine \indexpetscdef{PetscGetCPUTime} is less useful, since it measures only
time spent in computation, and ignores things such as communication.

\Level 0 {Memory management}
\label{sec:petscmalloc}

Allocate the memory for a given pointer: \indexpetscdef{PetscNew},
allocate arbitrary memory with \indexpetscdef{PetscMalloc},
allocate a number of objects with \indexpetscref{PetscMalloc1}
(this does not zero the memory allocated,
 use \indexpetscdef{PetscCalloc1} to obtain memory that has been zeroed);
use \indexpetscref{PetscFree} to free.
\begin{lstlisting}
PetscInt *idxs;
PetscMalloc1(10,&idxs);
// better than:
// PetscMalloc(10*sizeof(PetscInt),&idxs);
for (PetscInt i=0; i<10; i++)
  idxs[i] = f(i);
PetscFree(idxs);
\end{lstlisting}
Allocated memory is aligned to \indexpetscdef{PETSC_MEMALIGN}.

The state of memory allocation can be written to file or standard out
with \indexpetscdef{PetscMallocDump}. The commandline option
\n{-malloc_dump} outputs all not-freed memory during
\indexpetscshow{PetscFinalize}.
